"""
Train ML Model and Generate P4 Code
===================================

Trains a Decision Tree model optimized for P4 deployment
and generates P4 match-action table entries.
"""

import json
import pickle
from pathlib import Path

import numpy as np
import pandas as pd
from sklearn.tree import DecisionTreeClassifier, export_text
from sklearn.metrics import accuracy_score, classification_report, f1_score

from .config import Config


def load_prepared_data(data_dir: Path) -> dict:
    """Load prepared dataset from files."""
    train_df = pd.read_csv(data_dir / "train.csv")
    test_df = pd.read_csv(data_dir / "test.csv")
    
    with open(data_dir / "metadata.json") as f:
        metadata = json.load(f)
    
    return {
        "X_train": train_df.drop("label", axis=1),
        "X_test": test_df.drop("label", axis=1),
        "y_train": train_df["label"],
        "y_test": test_df["label"],
        "features": metadata["features"],
        "label_mapping": metadata["label_mapping"],
        "config": metadata["config"],
    }


def train_decision_tree(data: dict, config: Config) -> DecisionTreeClassifier:
    """
    Train a Decision Tree optimized for P4 deployment.
    
    Decision Trees are ideal for P4 because:
    - Direct mapping to match-action tables
    - Each level = ~1 pipeline stage
    - Integer comparisons (no floating point)
    """
    print("\nTraining Decision Tree...")
    print(f"  max_depth: {config.max_tree_depth}")
    print(f"  min_samples_leaf: {config.min_samples_leaf}")
    
    dt = DecisionTreeClassifier(
        max_depth=config.max_tree_depth,
        min_samples_leaf=config.min_samples_leaf,
        random_state=config.random_state
    )
    
    dt.fit(data["X_train"], data["y_train"])
    
    # Evaluate
    y_pred = dt.predict(data["X_test"])
    accuracy = accuracy_score(data["y_test"], y_pred)
    f1 = f1_score(data["y_test"], y_pred, average="macro")
    
    print(f"\nModel Performance:")
    print(f"  Accuracy: {accuracy:.4f}")
    print(f"  F1-Score: {f1:.4f}")
    print(f"  Tree depth: {dt.get_depth()}")
    print(f"  Leaf nodes: {dt.get_n_leaves()}")
    
    print(f"\nClassification Report:")
    labels = ["Normal", "Attack"] if data["config"]["binary"] else list(data["label_mapping"].keys())
    print(classification_report(data["y_test"], y_pred, target_names=labels))
    
    return dt


def extract_tree_rules(dt: DecisionTreeClassifier, feature_names: list) -> list:
    """Extract rules from Decision Tree for P4 table generation."""
    tree = dt.tree_
    rules = []
    
    def recurse(node: int, path: list):
        if tree.feature[node] == -2:  # Leaf node
            rules.append({
                "path": path.copy(),
                "class": int(np.argmax(tree.value[node])),
                "samples": int(tree.n_node_samples[node])
            })
        else:
            feature = feature_names[tree.feature[node]]
            threshold = int(tree.threshold[node])
            
            # Left child (<=)
            path.append({"feature": feature, "threshold": threshold, "operator": "<="})
            recurse(tree.children_left[node], path)
            path.pop()
            
            # Right child (>)
            path.append({"feature": feature, "threshold": threshold, "operator": ">"})
            recurse(tree.children_right[node], path)
            path.pop()
    
    recurse(0, [])
    return rules


def generate_p4_commands(rules: list, features: list) -> str:
    """Generate simple_switch_CLI commands for BMv2."""
    lines = [
        "# P4 Table Commands for ML Classification",
        "# Generated by planter-unsw-bmv2",
        f"# Features: {features}",
        "",
    ]
    
    # Generate feature threshold tables
    for i, feat in enumerate(features):
        thresholds = set()
        for rule in rules:
            for step in rule["path"]:
                if step["feature"] == feat:
                    thresholds.add(step["threshold"])
        
        if thresholds:
            lines.append(f"# Table: ml_feature_{i} ({feat})")
            for t in sorted(thresholds):
                lines.append(f"table_add ml_feature_{i} set_code_{i} 0->{t} => 0")
                lines.append(f"table_add ml_feature_{i} set_code_{i} {t+1}->255 => 1")
            lines.append("")
    
    lines.append("# Classification table")
    lines.append("table_add ml_classify classify 0 0 0 => 0  # Normal")
    lines.append("table_add ml_classify classify 1 1 1 => 1  # Attack")
    
    return "\n".join(lines)


def save_model_artifacts(
    dt: DecisionTreeClassifier,
    rules: list,
    features: list,
    output_dir: Path
) -> None:
    """Save model and generated artifacts."""
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Save model
    with open(output_dir / "model.pkl", "wb") as f:
        pickle.dump(dt, f)
    
    # Save tree rules (convert numpy types to Python types for JSON)
    def convert_numpy(obj):
        if isinstance(obj, np.integer):
            return int(obj)
        elif isinstance(obj, np.floating):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        elif isinstance(obj, dict):
            return {k: convert_numpy(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [convert_numpy(i) for i in obj]
        return obj
    
    with open(output_dir / "tree_rules.json", "w") as f:
        json.dump(convert_numpy({
            "rules": rules,
            "features": features,
            "tree_depth": dt.get_depth(),
            "n_leaves": dt.get_n_leaves()
        }), f, indent=2)
    
    # Save tree structure (text)
    tree_text = export_text(dt, feature_names=features)
    with open(output_dir / "tree_structure.txt", "w") as f:
        f.write(tree_text)
    
    # Save P4 commands
    commands = generate_p4_commands(rules, features)
    with open(output_dir / "table_commands.txt", "w") as f:
        f.write(commands)
    
    print(f"\nSaved artifacts to {output_dir}")


def main():
    """Main entry point for model training."""
    print("=" * 60)
    print("Train ML Model and Generate P4 Code")
    print("=" * 60)
    
    config = Config()
    
    # Check if data is prepared (need train.csv, test.csv, and metadata.json)
    required_files = ["train.csv", "test.csv", "metadata.json"]
    missing = [f for f in required_files if not (config.data_dir / f).exists()]
    if missing:
        print(f"Missing data files: {missing}")
        print("Running data preparation...")
        from .prepare_data import main as prepare_main
        prepare_main()
    
    # Load data
    data = load_prepared_data(config.data_dir)
    print(f"Loaded {len(data['X_train'])} training samples")
    
    # Train model
    dt = train_decision_tree(data, config)
    
    # Extract rules
    rules = extract_tree_rules(dt, data["features"])
    print(f"\nExtracted {len(rules)} decision rules")
    
    # Save artifacts
    save_model_artifacts(dt, rules, data["features"], config.output_dir)
    
    print("\n" + "=" * 60)
    print("Training complete!")
    print("=" * 60)
    print(f"\nP4 Implementation:")
    print(f"  Pipeline stages needed: {dt.get_depth()}")
    print(f"  Classification entries: {dt.get_n_leaves()}")


if __name__ == "__main__":
    main()
